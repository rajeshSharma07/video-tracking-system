{"ast":null,"code":"/**\n * Merge overlapping intervals\n * @param {Array} intervals - Array of intervals with start and end times\n * @returns {Array} - Merged intervals\n */\nexport const mergeIntervals = intervals => {\n  if (!intervals || intervals.length === 0) return [];\n\n  // Sort intervals by start time\n  const sortedIntervals = [...intervals].sort((a, b) => a.start - b.start);\n  const result = [sortedIntervals[0]];\n  for (let i = 1; i < sortedIntervals.length; i++) {\n    const current = sortedIntervals[i];\n    const lastMerged = result[result.length - 1];\n\n    // If current interval overlaps with the last merged interval, merge them\n    if (current.start <= lastMerged.end + 1) {\n      lastMerged.end = Math.max(lastMerged.end, current.end);\n    } else {\n      // Otherwise, add the current interval to the result\n      result.push(current);\n    }\n  }\n  return result;\n};\n\n/**\n * Calculate total unique watched time from intervals\n * @param {Array} intervals - Array of merged intervals with start and end times\n * @returns {Number} - Total unique watched time in seconds\n */\nexport const calculateUniqueWatchedTime = intervals => {\n  if (!intervals || intervals.length === 0) return 0;\n  return intervals.reduce((total, interval) => {\n    return total + (interval.end - interval.start + 1);\n  }, 0);\n};\n\n/**\n * Calculate progress percentage\n * @param {Array} intervals - Array of merged intervals with start and end times\n * @param {Number} duration - Total duration of the video in seconds\n * @returns {Number} - Progress percentage (0-100)\n */\nexport const calculateProgressPercentage = (intervals, duration) => {\n  if (!duration) return 0;\n  const totalWatchedSeconds = calculateUniqueWatchedTime(intervals);\n  return totalWatchedSeconds / duration * 100;\n};\n\n/**\n * Check if a specific time has been watched\n * @param {Array} intervals - Array of watched intervals\n * @param {Number} time - Time to check\n * @returns {Boolean} - Whether the time has been watched\n */\nexport const isTimeWatched = (intervals, time) => {\n  if (!intervals || intervals.length === 0) return false;\n  return intervals.some(interval => time >= interval.start && time <= interval.end);\n};\n\n/**\n * Get unwatched segments\n * @param {Array} intervals - Array of watched intervals\n * @param {Number} duration - Total video duration\n * @returns {Array} - Array of unwatched segments\n */\nexport const getUnwatchedSegments = (intervals, duration) => {\n  if (!intervals || intervals.length === 0) {\n    return [{\n      start: 0,\n      end: duration - 1\n    }];\n  }\n  const mergedIntervals = mergeIntervals(intervals);\n  const unwatched = [];\n\n  // Check if there's an unwatched segment at the beginning\n  if (mergedIntervals[0].start > 0) {\n    unwatched.push({\n      start: 0,\n      end: mergedIntervals[0].start - 1\n    });\n  }\n\n  // Check for unwatched segments between watched intervals\n  for (let i = 0; i < mergedIntervals.length - 1; i++) {\n    if (mergedIntervals[i].end + 1 < mergedIntervals[i + 1].start) {\n      unwatched.push({\n        start: mergedIntervals[i].end + 1,\n        end: mergedIntervals[i + 1].start - 1\n      });\n    }\n  }\n\n  // Check if there's an unwatched segment at the end\n  const lastInterval = mergedIntervals[mergedIntervals.length - 1];\n  if (lastInterval.end < duration - 1) {\n    unwatched.push({\n      start: lastInterval.end + 1,\n      end: duration - 1\n    });\n  }\n  return unwatched;\n};","map":{"version":3,"names":["mergeIntervals","intervals","length","sortedIntervals","sort","a","b","start","result","i","current","lastMerged","end","Math","max","push","calculateUniqueWatchedTime","reduce","total","interval","calculateProgressPercentage","duration","totalWatchedSeconds","isTimeWatched","time","some","getUnwatchedSegments","mergedIntervals","unwatched","lastInterval"],"sources":["C:/Users/DELL/Desktop/Video-Progress-Tracker-main/video-progress-frontend-main/src/utils/progressUtils.js"],"sourcesContent":["/**\n * Merge overlapping intervals\n * @param {Array} intervals - Array of intervals with start and end times\n * @returns {Array} - Merged intervals\n */\nexport const mergeIntervals = (intervals) => {\n  if (!intervals || intervals.length === 0) return [];\n\n  // Sort intervals by start time\n  const sortedIntervals = [...intervals].sort((a, b) => a.start - b.start);\n\n  const result = [sortedIntervals[0]];\n\n  for (let i = 1; i < sortedIntervals.length; i++) {\n    const current = sortedIntervals[i];\n    const lastMerged = result[result.length - 1];\n\n    // If current interval overlaps with the last merged interval, merge them\n    if (current.start <= lastMerged.end + 1) {\n      lastMerged.end = Math.max(lastMerged.end, current.end);\n    } else {\n      // Otherwise, add the current interval to the result\n      result.push(current);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Calculate total unique watched time from intervals\n * @param {Array} intervals - Array of merged intervals with start and end times\n * @returns {Number} - Total unique watched time in seconds\n */\nexport const calculateUniqueWatchedTime = (intervals) => {\n  if (!intervals || intervals.length === 0) return 0;\n\n  return intervals.reduce((total, interval) => {\n    return total + (interval.end - interval.start + 1);\n  }, 0);\n};\n\n/**\n * Calculate progress percentage\n * @param {Array} intervals - Array of merged intervals with start and end times\n * @param {Number} duration - Total duration of the video in seconds\n * @returns {Number} - Progress percentage (0-100)\n */\nexport const calculateProgressPercentage = (intervals, duration) => {\n  if (!duration) return 0;\n\n  const totalWatchedSeconds = calculateUniqueWatchedTime(intervals);\n  return (totalWatchedSeconds / duration) * 100;\n};\n\n/**\n * Check if a specific time has been watched\n * @param {Array} intervals - Array of watched intervals\n * @param {Number} time - Time to check\n * @returns {Boolean} - Whether the time has been watched\n */\nexport const isTimeWatched = (intervals, time) => {\n  if (!intervals || intervals.length === 0) return false;\n\n  return intervals.some(interval => time >= interval.start && time <= interval.end);\n};\n\n/**\n * Get unwatched segments\n * @param {Array} intervals - Array of watched intervals\n * @param {Number} duration - Total video duration\n * @returns {Array} - Array of unwatched segments\n */\nexport const getUnwatchedSegments = (intervals, duration) => {\n  if (!intervals || intervals.length === 0) {\n    return [{ start: 0, end: duration - 1 }];\n  }\n\n  const mergedIntervals = mergeIntervals(intervals);\n  const unwatched = [];\n\n  // Check if there's an unwatched segment at the beginning\n  if (mergedIntervals[0].start > 0) {\n    unwatched.push({ start: 0, end: mergedIntervals[0].start - 1 });\n  }\n\n  // Check for unwatched segments between watched intervals\n  for (let i = 0; i < mergedIntervals.length - 1; i++) {\n    if (mergedIntervals[i].end + 1 < mergedIntervals[i + 1].start) {\n      unwatched.push({\n        start: mergedIntervals[i].end + 1,\n        end: mergedIntervals[i + 1].start - 1\n      });\n    }\n  }\n\n  // Check if there's an unwatched segment at the end\n  const lastInterval = mergedIntervals[mergedIntervals.length - 1];\n  if (lastInterval.end < duration - 1) {\n    unwatched.push({ start: lastInterval.end + 1, end: duration - 1 });\n  }\n\n  return unwatched;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}