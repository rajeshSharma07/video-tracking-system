{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useContext, useCallback } from 'react';\nimport { VideoContext } from '../contexts/VideoContext';\nimport { AuthContext } from '../contexts/AuthContext';\nimport { mergeIntervals, calculateUniqueWatchedTime, calculateProgressPercentage } from '../utils/progressUtils';\n\n/**\n * Custom hook for tracking video progress\n * @param {string} videoId - The ID of the video\n * @param {number} videoDuration - The total duration of the video in seconds\n * @returns {Object} - Methods and state for tracking progress\n */\nconst useVideoProgress = (videoId, videoDuration) => {\n  _s();\n  const {\n    progress,\n    updateProgress,\n    getVideoProgress\n  } = useContext(VideoContext);\n  const {\n    isAuthenticated\n  } = useContext(AuthContext);\n\n  // State for tracking watched intervals\n  const [watchedIntervals, setWatchedIntervals] = useState([]);\n  const [currentInterval, setCurrentInterval] = useState(null);\n  const [progressPercentage, setProgressPercentage] = useState(0);\n  const [lastPosition, setLastPosition] = useState(0);\n\n  // Refs for tracking\n  const playerRef = useRef(null);\n  const isPlayingRef = useRef(false);\n  const lastTimeUpdateRef = useRef(0);\n  const updateIntervalRef = useRef(null);\n  const saveTimeoutRef = useRef(null);\n  const lastSaveTimeRef = useRef(0);\n\n  // Initialize progress from server\n  useEffect(() => {\n    const fetchProgress = async () => {\n      if (isAuthenticated && videoId) {\n        try {\n          const progressData = await getVideoProgress(videoId);\n          console.log('Fetched progress data:', progressData);\n          if (progressData && playerRef.current) {\n            // Seek to last position when video loads if it's not at the very beginning\n            if (progressData.lastPosition > 0 && progressData.lastPosition < videoDuration) {\n              playerRef.current.seekTo(progressData.lastPosition, 'seconds');\n              setLastPosition(progressData.lastPosition);\n            }\n          }\n        } catch (error) {\n          console.error('Error fetching progress:', error);\n        }\n      }\n    };\n    fetchProgress();\n    return () => {\n      // Clean up intervals and timeouts\n      if (updateIntervalRef.current) {\n        clearInterval(updateIntervalRef.current);\n      }\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, [videoId, getVideoProgress, isAuthenticated, videoDuration]);\n\n  // Update local state when progress changes from server\n  useEffect(() => {\n    if (progress) {\n      console.log('Progress updated from server:', progress);\n      setWatchedIntervals(progress.watchedIntervals || []);\n      setProgressPercentage(progress.progressPercentage || 0);\n      setLastPosition(progress.lastPosition || 0);\n    }\n  }, [progress]);\n\n  // Save progress to server with debounce\n  const saveProgress = useCallback((intervals, percentage, currentTime) => {\n    // Only save progress if authenticated\n    if (!isAuthenticated) return;\n\n    // Don't save too frequently\n    const now = Date.now();\n    if (now - lastSaveTimeRef.current < 5000) {\n      // 5 seconds minimum between saves\n      return;\n    }\n\n    // Clear previous timeout\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    // Set new timeout to save progress\n    saveTimeoutRef.current = setTimeout(async () => {\n      if (!playerRef.current) {\n        console.warn('Player reference not available when saving progress');\n        return;\n      }\n      try {\n        let timeToSave = currentTime;\n        if (typeof timeToSave !== 'number') {\n          try {\n            timeToSave = Math.floor(playerRef.current.getCurrentTime());\n          } catch (error) {\n            console.error('Error getting current time:', error);\n            timeToSave = lastPosition;\n          }\n        }\n        console.log('Saving progress:', {\n          videoId,\n          intervals,\n          currentTime: timeToSave,\n          percentage\n        });\n        await updateProgress(videoId, {\n          intervals,\n          currentTime: timeToSave,\n          progressPercentage: percentage\n        });\n        lastSaveTimeRef.current = Date.now();\n      } catch (error) {\n        console.error('Error saving progress:', error);\n      }\n    }, 1000); // Debounce for 1 second\n  }, [isAuthenticated, lastPosition, updateProgress, videoId]);\n\n  // Start tracking when video plays\n  const handlePlay = useCallback(() => {\n    if (!playerRef.current) {\n      console.warn('Player reference is not set in handlePlay');\n      return;\n    }\n    isPlayingRef.current = true;\n    try {\n      // Start a new interval if not already tracking\n      if (!currentInterval) {\n        let currentTime;\n        try {\n          currentTime = Math.floor(playerRef.current.getCurrentTime());\n        } catch (error) {\n          console.error('Error getting current time:', error);\n          currentTime = 0;\n        }\n        console.log('Starting new interval at:', currentTime);\n        setCurrentInterval({\n          start: currentTime,\n          end: currentTime\n        });\n      }\n\n      // Start interval to update current interval while playing\n      if (!updateIntervalRef.current) {\n        updateIntervalRef.current = setInterval(() => {\n          if (isPlayingRef.current && playerRef.current) {\n            try {\n              const currentTime = Math.floor(playerRef.current.getCurrentTime());\n\n              // Update the end time of the current interval\n              setCurrentInterval(prev => {\n                if (prev) {\n                  // Only log occasionally to reduce console spam\n                  if (currentTime % 5 === 0) {\n                    console.log('Updating interval:', {\n                      ...prev,\n                      end: currentTime\n                    });\n                  }\n                  return {\n                    ...prev,\n                    end: currentTime\n                  };\n                }\n                console.log('Creating new interval:', {\n                  start: currentTime,\n                  end: currentTime\n                });\n                return {\n                  start: currentTime,\n                  end: currentTime\n                };\n              });\n\n              // Update last time update\n              lastTimeUpdateRef.current = currentTime;\n\n              // Update progress percentage in real-time\n              if (currentInterval) {\n                const tempIntervals = [...watchedIntervals, {\n                  ...currentInterval,\n                  end: currentTime\n                }];\n                const mergedTempIntervals = mergeIntervals(tempIntervals);\n                const newPercentage = calculateProgressPercentage(mergedTempIntervals, videoDuration);\n                setProgressPercentage(newPercentage);\n\n                // Save progress periodically while playing\n                saveProgress(mergedTempIntervals, newPercentage, currentTime);\n              }\n            } catch (error) {\n              console.error('Error updating interval:', error);\n            }\n          }\n        }, 1000); // Update every second\n      }\n    } catch (error) {\n      console.error('Error in handlePlay:', error);\n    }\n  }, [calculateProgressPercentage, currentInterval, mergeIntervals, saveProgress, videoDuration, watchedIntervals]);\n\n  // Stop tracking when video pauses\n  const handlePause = useCallback(() => {\n    console.log('Handling pause, isPlaying:', isPlayingRef.current);\n    isPlayingRef.current = false;\n\n    // Add the current interval to watched intervals if it exists\n    if (currentInterval) {\n      console.log('Current interval on pause:', currentInterval);\n      setWatchedIntervals(prev => {\n        const newIntervals = [...prev, currentInterval];\n        console.log('All intervals before merge:', newIntervals);\n        const mergedIntervals = mergeIntervals(newIntervals);\n        console.log('Merged intervals:', mergedIntervals);\n\n        // Calculate new progress percentage\n        const newPercentage = calculateProgressPercentage(mergedIntervals, videoDuration);\n        console.log('New progress percentage:', newPercentage);\n        setProgressPercentage(newPercentage);\n\n        // Save progress to server if authenticated\n        if (isAuthenticated) {\n          saveProgress(mergedIntervals, newPercentage);\n        }\n        return mergedIntervals;\n      });\n\n      // Reset current interval\n      setCurrentInterval(null);\n    }\n\n    // Clear update interval\n    if (updateIntervalRef.current) {\n      clearInterval(updateIntervalRef.current);\n      updateIntervalRef.current = null;\n    }\n  }, [calculateProgressPercentage, currentInterval, isAuthenticated, mergeIntervals, saveProgress, videoDuration]);\n\n  // Handle seeking in the video\n  const handleSeek = useCallback(seconds => {\n    console.log('Handling seek to:', seconds);\n    const currentTime = Math.floor(seconds);\n\n    // If playing, update the current interval or create a new one\n    if (isPlayingRef.current) {\n      // If the seek is far from the last update, end the current interval and start a new one\n      if (Math.abs(currentTime - lastTimeUpdateRef.current) > 3) {\n        console.log('Seek distance > 3, creating new interval');\n        // Add the current interval to watched intervals if it exists\n        if (currentInterval) {\n          setWatchedIntervals(prev => {\n            const newIntervals = [...prev, currentInterval];\n            return mergeIntervals(newIntervals);\n          });\n        }\n\n        // Start a new interval at the seek position\n        setCurrentInterval({\n          start: currentTime,\n          end: currentTime\n        });\n      }\n    }\n\n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n    setLastPosition(currentTime);\n  }, [currentInterval, mergeIntervals]);\n\n  // Handle video end\n  const handleEnded = useCallback(() => {\n    console.log('Handling video end');\n    isPlayingRef.current = false;\n\n    // Add the current interval to watched intervals if it exists\n    if (currentInterval) {\n      setWatchedIntervals(prev => {\n        const newIntervals = [...prev, currentInterval];\n        const mergedIntervals = mergeIntervals(newIntervals);\n\n        // Calculate new progress percentage\n        const newPercentage = calculateProgressPercentage(mergedIntervals, videoDuration);\n        setProgressPercentage(newPercentage);\n\n        // Save progress to server if authenticated\n        if (isAuthenticated) {\n          saveProgress(mergedIntervals, newPercentage);\n        }\n        return mergedIntervals;\n      });\n\n      // Reset current interval\n      setCurrentInterval(null);\n    }\n\n    // Clear update interval\n    if (updateIntervalRef.current) {\n      clearInterval(updateIntervalRef.current);\n      updateIntervalRef.current = null;\n    }\n  }, [calculateProgressPercentage, currentInterval, isAuthenticated, mergeIntervals, saveProgress, videoDuration]);\n\n  // Get player reference\n  const getPlayerRef = useCallback(player => {\n    console.log('Setting player reference in hook:', player);\n    playerRef.current = player;\n  }, []);\n  return {\n    watchedIntervals,\n    progressPercentage,\n    lastPosition,\n    getPlayerRef,\n    handlePlay,\n    handlePause,\n    handleSeek,\n    handleEnded\n  };\n};\n_s(useVideoProgress, \"JVxkjns7Zzk1ULimSQ9+ucsZgag=\");\nexport default useVideoProgress;","map":{"version":3,"names":["useState","useEffect","useRef","useContext","useCallback","VideoContext","AuthContext","mergeIntervals","calculateUniqueWatchedTime","calculateProgressPercentage","useVideoProgress","videoId","videoDuration","_s","progress","updateProgress","getVideoProgress","isAuthenticated","watchedIntervals","setWatchedIntervals","currentInterval","setCurrentInterval","progressPercentage","setProgressPercentage","lastPosition","setLastPosition","playerRef","isPlayingRef","lastTimeUpdateRef","updateIntervalRef","saveTimeoutRef","lastSaveTimeRef","fetchProgress","progressData","console","log","current","seekTo","error","clearInterval","clearTimeout","saveProgress","intervals","percentage","currentTime","now","Date","setTimeout","warn","timeToSave","Math","floor","getCurrentTime","handlePlay","start","end","setInterval","prev","tempIntervals","mergedTempIntervals","newPercentage","handlePause","newIntervals","mergedIntervals","handleSeek","seconds","abs","handleEnded","getPlayerRef","player"],"sources":["C:/Users/DELL/Desktop/Video-Progress-Tracker-main/video-progress-frontend-main/src/hooks/useVideoProgress.js"],"sourcesContent":["import { useState, useEffect, useRef, useContext, useCallback } from 'react';\nimport { VideoContext } from '../contexts/VideoContext';\nimport { AuthContext } from '../contexts/AuthContext';\nimport { mergeIntervals, calculateUniqueWatchedTime, calculateProgressPercentage } from '../utils/progressUtils';\n\n/**\n * Custom hook for tracking video progress\n * @param {string} videoId - The ID of the video\n * @param {number} videoDuration - The total duration of the video in seconds\n * @returns {Object} - Methods and state for tracking progress\n */\nconst useVideoProgress = (videoId, videoDuration) => {\n  const { progress, updateProgress, getVideoProgress } = useContext(VideoContext);\n  const { isAuthenticated } = useContext(AuthContext);\n\n  // State for tracking watched intervals\n  const [watchedIntervals, setWatchedIntervals] = useState([]);\n  const [currentInterval, setCurrentInterval] = useState(null);\n  const [progressPercentage, setProgressPercentage] = useState(0);\n  const [lastPosition, setLastPosition] = useState(0);\n\n  // Refs for tracking\n  const playerRef = useRef(null);\n  const isPlayingRef = useRef(false);\n  const lastTimeUpdateRef = useRef(0);\n  const updateIntervalRef = useRef(null);\n  const saveTimeoutRef = useRef(null);\n  const lastSaveTimeRef = useRef(0);\n\n  // Initialize progress from server\n  useEffect(() => {\n    const fetchProgress = async () => {\n      if (isAuthenticated && videoId) {\n        try {\n          const progressData = await getVideoProgress(videoId);\n          console.log('Fetched progress data:', progressData);\n          if (progressData && playerRef.current) {\n            // Seek to last position when video loads if it's not at the very beginning\n            if (progressData.lastPosition > 0 && progressData.lastPosition < videoDuration) {\n                playerRef.current.seekTo(progressData.lastPosition, 'seconds');\n                setLastPosition(progressData.lastPosition);\n            }\n          }\n        } catch (error) {\n          console.error('Error fetching progress:', error);\n        }\n      }\n    };\n\n    fetchProgress();\n\n    return () => {\n      // Clean up intervals and timeouts\n      if (updateIntervalRef.current) {\n        clearInterval(updateIntervalRef.current);\n      }\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, [videoId, getVideoProgress, isAuthenticated, videoDuration]);\n\n  // Update local state when progress changes from server\n  useEffect(() => {\n    if (progress) {\n      console.log('Progress updated from server:', progress);\n      setWatchedIntervals(progress.watchedIntervals || []);\n      setProgressPercentage(progress.progressPercentage || 0);\n      setLastPosition(progress.lastPosition || 0);\n    }\n  }, [progress]);\n\n  // Save progress to server with debounce\n  const saveProgress = useCallback((intervals, percentage, currentTime) => {\n    // Only save progress if authenticated\n    if (!isAuthenticated) return;\n\n    // Don't save too frequently\n    const now = Date.now();\n    if (now - lastSaveTimeRef.current < 5000) { // 5 seconds minimum between saves\n      return;\n    }\n\n    // Clear previous timeout\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    // Set new timeout to save progress\n    saveTimeoutRef.current = setTimeout(async () => {\n      if (!playerRef.current) {\n        console.warn('Player reference not available when saving progress');\n        return;\n      }\n\n      try {\n        let timeToSave = currentTime;\n        if (typeof timeToSave !== 'number') {\n          try {\n            timeToSave = Math.floor(playerRef.current.getCurrentTime());\n          } catch (error) {\n            console.error('Error getting current time:', error);\n            timeToSave = lastPosition;\n          }\n        }\n\n        console.log('Saving progress:', {\n          videoId,\n          intervals,\n          currentTime: timeToSave,\n          percentage\n        });\n\n        await updateProgress(videoId, {\n          intervals,\n          currentTime: timeToSave,\n          progressPercentage: percentage\n        });\n\n        lastSaveTimeRef.current = Date.now();\n      } catch (error) {\n        console.error('Error saving progress:', error);\n      }\n    }, 1000); // Debounce for 1 second\n  }, [isAuthenticated, lastPosition, updateProgress, videoId]);\n\n  // Start tracking when video plays\n  const handlePlay = useCallback(() => {\n    if (!playerRef.current) {\n      console.warn('Player reference is not set in handlePlay');\n      return;\n    }\n\n    isPlayingRef.current = true;\n\n    try {\n      // Start a new interval if not already tracking\n      if (!currentInterval) {\n        let currentTime;\n        try {\n          currentTime = Math.floor(playerRef.current.getCurrentTime());\n        } catch (error) {\n          console.error('Error getting current time:', error);\n          currentTime = 0;\n        }\n\n        console.log('Starting new interval at:', currentTime);\n        setCurrentInterval({ start: currentTime, end: currentTime });\n      }\n\n      // Start interval to update current interval while playing\n      if (!updateIntervalRef.current) {\n        updateIntervalRef.current = setInterval(() => {\n          if (isPlayingRef.current && playerRef.current) {\n            try {\n              const currentTime = Math.floor(playerRef.current.getCurrentTime());\n\n              // Update the end time of the current interval\n              setCurrentInterval(prev => {\n                if (prev) {\n                  // Only log occasionally to reduce console spam\n                  if (currentTime % 5 === 0) {\n                    console.log('Updating interval:', { ...prev, end: currentTime });\n                  }\n                  return { ...prev, end: currentTime };\n                }\n                console.log('Creating new interval:', { start: currentTime, end: currentTime });\n                return { start: currentTime, end: currentTime };\n              });\n\n              // Update last time update\n              lastTimeUpdateRef.current = currentTime;\n\n              // Update progress percentage in real-time\n              if (currentInterval) {\n                const tempIntervals = [...watchedIntervals, { ...currentInterval, end: currentTime }];\n                const mergedTempIntervals = mergeIntervals(tempIntervals);\n                const newPercentage = calculateProgressPercentage(mergedTempIntervals, videoDuration);\n                setProgressPercentage(newPercentage);\n\n                // Save progress periodically while playing\n                saveProgress(mergedTempIntervals, newPercentage, currentTime);\n              }\n            } catch (error) {\n              console.error('Error updating interval:', error);\n            }\n          }\n        }, 1000); // Update every second\n      }\n    } catch (error) {\n      console.error('Error in handlePlay:', error);\n    }\n  }, [calculateProgressPercentage, currentInterval, mergeIntervals, saveProgress, videoDuration, watchedIntervals]);\n\n  // Stop tracking when video pauses\n  const handlePause = useCallback(() => {\n    console.log('Handling pause, isPlaying:', isPlayingRef.current);\n    isPlayingRef.current = false;\n\n    // Add the current interval to watched intervals if it exists\n    if (currentInterval) {\n      console.log('Current interval on pause:', currentInterval);\n      setWatchedIntervals(prev => {\n        const newIntervals = [...prev, currentInterval];\n        console.log('All intervals before merge:', newIntervals);\n        const mergedIntervals = mergeIntervals(newIntervals);\n        console.log('Merged intervals:', mergedIntervals);\n\n        // Calculate new progress percentage\n        const newPercentage = calculateProgressPercentage(mergedIntervals, videoDuration);\n        console.log('New progress percentage:', newPercentage);\n        setProgressPercentage(newPercentage);\n\n        // Save progress to server if authenticated\n        if (isAuthenticated) {\n          saveProgress(mergedIntervals, newPercentage);\n        }\n\n        return mergedIntervals;\n      });\n\n      // Reset current interval\n      setCurrentInterval(null);\n    }\n\n    // Clear update interval\n    if (updateIntervalRef.current) {\n      clearInterval(updateIntervalRef.current);\n      updateIntervalRef.current = null;\n    }\n  }, [calculateProgressPercentage, currentInterval, isAuthenticated, mergeIntervals, saveProgress, videoDuration]);\n\n  // Handle seeking in the video\n  const handleSeek = useCallback((seconds) => {\n    console.log('Handling seek to:', seconds);\n    const currentTime = Math.floor(seconds);\n\n    // If playing, update the current interval or create a new one\n    if (isPlayingRef.current) {\n      // If the seek is far from the last update, end the current interval and start a new one\n      if (Math.abs(currentTime - lastTimeUpdateRef.current) > 3) {\n        console.log('Seek distance > 3, creating new interval');\n        // Add the current interval to watched intervals if it exists\n        if (currentInterval) {\n          setWatchedIntervals(prev => {\n            const newIntervals = [...prev, currentInterval];\n            return mergeIntervals(newIntervals);\n          });\n        }\n\n        // Start a new interval at the seek position\n        setCurrentInterval({ start: currentTime, end: currentTime });\n      }\n    }\n\n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n    setLastPosition(currentTime);\n  }, [currentInterval, mergeIntervals]);\n\n  // Handle video end\n  const handleEnded = useCallback(() => {\n    console.log('Handling video end');\n    isPlayingRef.current = false;\n\n    // Add the current interval to watched intervals if it exists\n    if (currentInterval) {\n      setWatchedIntervals(prev => {\n        const newIntervals = [...prev, currentInterval];\n        const mergedIntervals = mergeIntervals(newIntervals);\n\n        // Calculate new progress percentage\n        const newPercentage = calculateProgressPercentage(mergedIntervals, videoDuration);\n        setProgressPercentage(newPercentage);\n\n        // Save progress to server if authenticated\n        if (isAuthenticated) {\n          saveProgress(mergedIntervals, newPercentage);\n        }\n\n        return mergedIntervals;\n      });\n\n      // Reset current interval\n      setCurrentInterval(null);\n    }\n\n    // Clear update interval\n    if (updateIntervalRef.current) {\n      clearInterval(updateIntervalRef.current);\n      updateIntervalRef.current = null;\n    }\n  }, [calculateProgressPercentage, currentInterval, isAuthenticated, mergeIntervals, saveProgress, videoDuration]);\n\n  // Get player reference\n  const getPlayerRef = useCallback((player) => {\n    console.log('Setting player reference in hook:', player);\n    playerRef.current = player;\n  }, []);\n\n  return {\n    watchedIntervals,\n    progressPercentage,\n    lastPosition,\n    getPlayerRef,\n    handlePlay,\n    handlePause,\n    handleSeek,\n    handleEnded\n  };\n};\n\nexport default useVideoProgress;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}